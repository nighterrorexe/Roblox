-- VoidHub Library v2 - Premium Edition
local VoidHub = {}

local ValidKeys = {
    "AccessHubForKeySystem1"
}

local BypassKey = false
local ExecuteAfterKey = nil
local SavedKey = nil
local player = game.Players.LocalPlayer
local PlayerGui = player:WaitForChild("PlayerGui")

-- TweenService for smooth animations
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")

-- Key validation and file management
if isfile and isfile("VoidHubKey.txt") then
    SavedKey = readfile("VoidHubKey.txt")
    if table.find(ValidKeys, SavedKey) then
        BypassKey = true
        print("‚úÖ Valid key found in file. Bypassing key system.")
    else
        -- Remove invalid key file
        pcall(function()
            delfile("VoidHubKey.txt")
            print("‚ùå Invalid key found in file. File removed.")
        end)
        SavedKey = nil
        BypassKey = false
    end
end

function VoidHub:Execute(codeOrFunction)
    if type(codeOrFunction) == "string" then
        local success, err = pcall(function()
            loadstring(game:HttpGet(codeOrFunction, true))()
        end)
        if not success then
            warn("VoidHub Execute Error: " .. tostring(err))
        end
    elseif type(codeOrFunction) == "function" then
        pcall(codeOrFunction)
    end
end

function VoidHub:SaveKey(key)
    if key and table.find(ValidKeys, key) then
        -- Remove existing key file if it exists and has invalid key
        if isfile and isfile("VoidHubKey.txt") then
            local existingKey = readfile("VoidHubKey.txt")
            if not table.find(ValidKeys, existingKey) then
                pcall(function()
                    delfile("VoidHubKey.txt")
                    print("üóëÔ∏è Removed invalid key file")
                end)
            end
        end
        
        -- Save the new valid key
        SavedKey = key
        BypassKey = true
        
        if writefile then
            local success, err = pcall(function()
                writefile("VoidHubKey.txt", key)
            end)
            if success then
                print("‚úÖ Key saved successfully to file: " .. key)
            else
                warn("‚ùå Failed to save key: " .. tostring(err))
            end
        end
    else
        print("‚ùå Invalid key provided, not saving to file.")
    end
end

function VoidHub:ValidateAndCleanKeyFile()
    -- This function can be called to validate existing key file
    if isfile and isfile("VoidHubKey.txt") then
        local fileKey = readfile("VoidHubKey.txt")
        if not table.find(ValidKeys, fileKey) then
            pcall(function()
                delfile("VoidHubKey.txt")
                print("üßπ Cleaned up invalid key file")
            end)
            return false
        else
            return true
        end
    end
    return false
end

function VoidHub:RemoveKeyFile()
    -- Function to manually remove key file
    if isfile and isfile("VoidHubKey.txt") then
        pcall(function()
            delfile("VoidHubKey.txt")
            print("üóëÔ∏è Key file removed")
        end)
        SavedKey = nil
        BypassKey = false
        return true
    end
    return false
end

function VoidHub:GetKeyStatus()
    -- Returns key status information
    return {
        HasValidKey = BypassKey,
        SavedKey = SavedKey,
        KeyFileExists = isfile and isfile("VoidHubKey.txt") or false
    }
end

function VoidHub:SetExecute(codeOrFunction)
    ExecuteAfterKey = codeOrFunction
    if BypassKey then
        self:Execute(ExecuteAfterKey)
    end
end

function VoidHub:CreateWindow()
    -- Validate existing key file on window creation
    self:ValidateAndCleanKeyFile()
    
    if BypassKey and table.find(ValidKeys, SavedKey) then
        if ExecuteAfterKey then
            self:Execute(ExecuteAfterKey)
        end
        return
    end

    if PlayerGui:FindFirstChild("VoidHubKeyUI") then return end

    -- Animation presets
    local tweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local tweenInfoBounce = TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
    local tweenInfoElastic = TweenInfo.new(0.7, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out)

    local function createGlowEffect(parent)
        local glow = Instance.new("ImageLabel")
        glow.Name = "Glow"
        glow.Size = UDim2.new(1, 20, 1, 20)
        glow.Position = UDim2.new(0, -10, 0, -10)
        glow.BackgroundTransparency = 1
        glow.Image = "rbxassetid://8992231221"
        glow.ImageColor3 = Color3.fromRGB(148, 0, 211) -- Purple glow
        glow.ScaleType = Enum.ScaleType.Slice
        glow.SliceCenter = Rect.new(100, 100, 100, 100)
        glow.SliceScale = 0.02
        glow.Parent = parent
        return glow
    end

    local function createLoadingAnimation(parent)
        local loadingFrame = Instance.new("Frame")
        loadingFrame.Name = "LoadingAnimation"
        loadingFrame.Size = UDim2.new(0, 200, 0, 50)
        loadingFrame.Position = UDim2.new(0.5, -100, 0.5, -25)
        loadingFrame.BackgroundTransparency = 1
        loadingFrame.Visible = false
        loadingFrame.Parent = parent

        -- Create loading text
        local loadingText = Instance.new("TextLabel")
        loadingText.Text = "Verifying Key..."
        loadingText.Size = UDim2.new(1, 0, 0, 30)
        loadingText.Position = UDim2.new(0, 0, 0, 0)
        loadingText.BackgroundTransparency = 1
        loadingText.TextColor3 = Color3.fromRGB(255, 255, 255)
        loadingText.Font = Enum.Font.FredokaOne
        loadingText.TextSize = 16
        loadingText.Parent = loadingFrame

        -- Create dots container
        local dotsContainer = Instance.new("Frame")
        dotsContainer.Size = UDim2.new(0, 60, 0, 20)
        dotsContainer.Position = UDim2.new(0.5, -30, 1, -20)
        dotsContainer.BackgroundTransparency = 1
        dotsContainer.Parent = loadingFrame

        -- Create 3 dots
        local dots = {}
        for i = 1, 3 do
            local dot = Instance.new("Frame")
            dot.Size = UDim2.new(0, 12, 0, 12)
            dot.Position = UDim2.new(0, (i-1) * 20, 0, 0)
            dot.BackgroundColor3 = Color3.fromRGB(148, 0, 211)
            dot.BorderSizePixel = 0
            dot.Parent = dotsContainer

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(1, 0)
            corner.Parent = dot

            table.insert(dots, dot)
        end

        local function startLoadingAnimation()
            local connections = {}
            
            for i, dot in ipairs(dots) do
                local connection
                connection = RunService.Heartbeat:Connect(function()
                    if not loadingFrame.Visible or not loadingFrame.Parent then
                        connection:Disconnect()
                        return
                    end
                    
                    local time = tick()
                    local offset = (i - 1) * 0.3
                    local scale = 0.5 + math.abs(math.sin((time + offset) * 3)) * 0.5
                    
                    dot.Size = UDim2.new(0, 8 + 4 * scale, 0, 8 + 4 * scale)
                    dot.BackgroundTransparency = 0.3 + (1 - scale) * 0.7
                    
                    -- Center the dot after size change
                    local newSize = 8 + 4 * scale
                    dot.Position = UDim2.new(0, (i-1) * 20 + (12 - newSize)/2, 0, (12 - newSize)/2)
                end)
                table.insert(connections, connection)
            end
            
            -- Return a function to stop the animation
            return function()
                for _, connection in ipairs(connections) do
                    connection:Disconnect()
                end
                for i, dot in ipairs(dots) do
                    dot.Size = UDim2.new(0, 12, 0, 12)
                    dot.BackgroundTransparency = 0
                    dot.Position = UDim2.new(0, (i-1) * 20, 0, 0)
                end
            end
        end

        return loadingFrame, startLoadingAnimation
    end

    local Gui = Instance.new("ScreenGui")
    Gui.Name = "VoidHubKeyUI"
    Gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    Gui.Parent = PlayerGui

    -- Background blur effect
    local blur = Instance.new("BlurEffect")
    blur.Size = 0
    blur.Parent = game:GetService("Lighting")

    TweenService:Create(blur, tweenInfo, {Size = 10}):Play()

    -- Main container with glossy gradient
    local Main = Instance.new("Frame")
    Main.Size = UDim2.new(0, 400, 0, 300)
    Main.AnchorPoint = Vector2.new(0.5, 0.5)
    Main.Position = UDim2.new(0.5, 0, 0.5, 0)
    Main.BackgroundColor3 = Color3.fromRGB(40, 0, 60)
    Main.BackgroundTransparency = 0.1
    Main.ClipsDescendants = true
    Main.Parent = Gui

    -- Gradient effect
    local gradient = Instance.new("UIGradient")
    gradient.Rotation = 45
    gradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(128, 0, 128)), -- Purple
        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(75, 0, 130)), -- Indigo
        ColorSequenceKeypoint.new(1, Color3.fromRGB(148, 0, 211)) -- Dark Violet
    })
    gradient.Parent = Main

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 25)
    corner.Parent = Main

    local uistroke = Instance.new("UIStroke")
    uistroke.Thickness = 3
    uistroke.Color = Color3.fromRGB(148, 0, 211) -- Purple border
    uistroke.Transparency = 0.2
    uistroke.Parent = Main

    -- Add glow effect to main frame
    createGlowEffect(Main)

    -- Animate entrance
    Main.Size = UDim2.new(0, 0, 0, 0)
    TweenService:Create(Main, tweenInfoElastic, {Size = UDim2.new(0, 400, 0, 300)}):Play()

    -- Title with gradient text
    local Title = Instance.new("TextLabel")
    Title.Text = "VOID HUB"
    Title.Size = UDim2.new(0, 300, 0, 60)
    Title.Position = UDim2.new(0.5, -150, 0, 10)
    Title.TextScaled = true
    Title.Font = Enum.Font.FredokaOne
    Title.TextColor3 = Color3.fromRGB(255, 255, 255)
    Title.BackgroundTransparency = 1
    Title.TextStrokeTransparency = 0.8
    Title.TextStrokeColor3 = Color3.fromRGB(148, 0, 211)
    Title.Parent = Main

    local titleGradient = Instance.new("UIGradient")
    titleGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(199, 21, 133)), -- Medium Violet Red
        ColorSequenceKeypoint.new(1, Color3.fromRGB(148, 0, 211)) -- Dark Violet
    })
    titleGradient.Parent = Title

    -- Subtitle
    local Subtitle = Instance.new("TextLabel")
    Subtitle.Text = "PREMIUM EDITION"
    Subtitle.Size = UDim2.new(0, 200, 0, 25)
    Subtitle.Position = UDim2.new(0.5, -100, 0, 60)
    Subtitle.TextScaled = true
    Subtitle.Font = Enum.Font.FredokaOne
    Subtitle.TextColor3 = Color3.fromRGB(200, 180, 255)
    Subtitle.BackgroundTransparency = 1
    Subtitle.Parent = Main

    -- Key input field
    local EnterKey = Instance.new("TextBox")
    EnterKey.Name = "EnterKey"
    EnterKey.PlaceholderText = "Enter your key here..."
    EnterKey.Text = ""
    EnterKey.Size = UDim2.new(0, 300, 0, 50)
    EnterKey.Position = UDim2.new(0.5, -150, 0, 100)
    EnterKey.BackgroundColor3 = Color3.fromRGB(25, 0, 40)
    EnterKey.BackgroundTransparency = 0.2
    EnterKey.TextColor3 = Color3.fromRGB(255, 255, 255)
    EnterKey.PlaceholderColor3 = Color3.fromRGB(180, 160, 220)
    EnterKey.Font = Enum.Font.FredokaOne
    EnterKey.TextSize = 16
    EnterKey.Parent = Main

    local enterKeyCorner = Instance.new("UICorner")
    enterKeyCorner.CornerRadius = UDim.new(0, 12)
    enterKeyCorner.Parent = EnterKey

    local enterKeyStroke = Instance.new("UIStroke")
    enterKeyStroke.Thickness = 2
    enterKeyStroke.Color = Color3.fromRGB(148, 0, 211)
    enterKeyStroke.Transparency = 0.3
    enterKeyStroke.Parent = EnterKey

    -- Error message
    local Errortxt = Instance.new("TextLabel")
    Errortxt.Name = "Error"
    Errortxt.Size = UDim2.new(0, 350, 0, 30)
    Errortxt.Position = UDim2.new(0.5, -175, 0, 160)
    Errortxt.BackgroundTransparency = 1
    Errortxt.TextScaled = true
    Errortxt.TextColor3 = Color3.fromRGB(255, 255, 255)
    Errortxt.Font = Enum.Font.FredokaOne
    Errortxt.Visible = false
    Errortxt.Parent = Main

    -- Loading animation for buttons
    local loadingAnimation, startLoadingAnimation = createLoadingAnimation(Main)
    local stopLoadingAnimation = nil

    local function ShowError(msg, color)
        Errortxt.Visible = true
        Errortxt.Text = msg
        if color then
            Errortxt.TextColor3 = color
        end
        
        -- Pulse animation for error
        local pulseTween = TweenService:Create(
            Errortxt,
            TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, 0, true),
            {TextTransparency = 0.3}
        )
        pulseTween:Play()
        
        task.wait(3)
        
        local fadeOut = TweenService:Create(
            Errortxt,
            tweenInfo,
            {TextTransparency = 1}
        )
        fadeOut:Play()
        fadeOut.Completed:Wait()
        Errortxt.Visible = false
        Errortxt.TextTransparency = 0
    end

    -- Close button with special styling
    local closebtn = Instance.new("TextButton")
    closebtn.Name = "Close"
    closebtn.Text = "X"
    closebtn.TextScaled = true
    closebtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    closebtn.Font = Enum.Font.FredokaOne
    closebtn.Size = UDim2.new(0, 35, 0, 35)
    closebtn.Position = UDim2.new(1, -45, 0, 10)
    closebtn.BackgroundColor3 = Color3.fromRGB(128, 0, 128) -- Purple
    closebtn.BorderSizePixel = 0
    closebtn.Parent = Main

    local closeCorner = Instance.new("UICorner")
    closeCorner.CornerRadius = UDim.new(1, 0)
    closeCorner.Parent = closebtn

    -- Close button hover effects
    closebtn.MouseEnter:Connect(function()
        TweenService:Create(closebtn, tweenInfo, {
            BackgroundColor3 = Color3.fromRGB(148, 0, 211),
            Size = UDim2.new(0, 40, 0, 40)
        }):Play()
    end)

    closebtn.MouseLeave:Connect(function()
        TweenService:Create(closebtn, tweenInfo, {
            BackgroundColor3 = Color3.fromRGB(128, 0, 128),
            Size = UDim2.new(0, 35, 0, 35)
        }):Play()
    end)

    closebtn.MouseButton1Click:Connect(function()
        -- Close animation
        local closeTween = TweenService:Create(Main, tweenInfo, {
            Size = UDim2.new(0, 0, 0, 0),
            BackgroundTransparency = 1
        })
        
        local blurTween = TweenService:Create(blur, tweenInfo, {Size = 0})
        
        closeTween:Play()
        blurTween:Play()
        
        closeTween.Completed:Wait()
        Gui:Destroy()
        blur:Destroy()
    end)

    -- Get Key Button
    local Getbtn = Instance.new("TextButton")
    Getbtn.Name = "Get"
    Getbtn.Text = "GET KEY"
    Getbtn.Size = UDim2.new(0, 140, 0, 45)
    Getbtn.Position = UDim2.new(0.5, -150, 0, 200)
    Getbtn.BackgroundColor3 = Color3.fromRGB(75, 0, 130)
    Getbtn.BackgroundTransparency = 0.1
    Getbtn.Font = Enum.Font.FredokaOne
    Getbtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    Getbtn.TextSize = 16
    Getbtn.AutoButtonColor = false
    Getbtn.Parent = Main

    local getCorner = Instance.new("UICorner")
    getCorner.CornerRadius = UDim.new(0, 15)
    getCorner.Parent = Getbtn

    local getStroke = Instance.new("UIStroke")
    getStroke.Thickness = 2
    getStroke.Color = Color3.fromRGB(148, 0, 211)
    getStroke.Transparency = 0.2
    getStroke.Parent = Getbtn

    local getGradient = Instance.new("UIGradient")
    getGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(128, 0, 128)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(75, 0, 130))
    })
    getGradient.Parent = Getbtn

    -- Check Key Button
    local Checkbtn = Instance.new("TextButton")
    Checkbtn.Name = "Check"
    Checkbtn.Text = "CHECK KEY"
    Checkbtn.Size = UDim2.new(0, 140, 0, 45)
    Checkbtn.Position = UDim2.new(0.5, 10, 0, 200)
    Checkbtn.BackgroundColor3 = Color3.fromRGB(75, 0, 130)
    Checkbtn.BackgroundTransparency = 0.1
    Checkbtn.Font = Enum.Font.FredokaOne
    Checkbtn.TextColor3 = Color3.fromRGB(255, 255, 255)
    Checkbtn.TextSize = 16
    Checkbtn.AutoButtonColor = false
    Checkbtn.Parent = Main

    local checkCorner = Instance.new("UICorner")
    checkCorner.CornerRadius = UDim.new(0, 15)
    checkCorner.Parent = Checkbtn

    local checkStroke = Instance.new("UIStroke")
    checkStroke.Thickness = 2
    checkStroke.Color = Color3.fromRGB(148, 0, 211)
    checkStroke.Transparency = 0.2
    checkStroke.Parent = Checkbtn

    local checkGradient = Instance.new("UIGradient")
    checkGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, Color3.fromRGB(128, 0, 128)),
        ColorSequenceKeypoint.new(1, Color3.fromRGB(75, 0, 130))
    })
    checkGradient.Parent = Checkbtn

    -- Button hover effects for Get button
    Getbtn.MouseEnter:Connect(function()
        TweenService:Create(Getbtn, tweenInfo, {
            BackgroundTransparency = 0,
            Size = UDim2.new(0, 145, 0, 48)
        }):Play()
        TweenService:Create(getStroke, tweenInfo, {Transparency = 0}):Play()
    end)

    Getbtn.MouseLeave:Connect(function()
        TweenService:Create(Getbtn, tweenInfo, {
            BackgroundTransparency = 0.1,
            Size = UDim2.new(0, 140, 0, 45)
        }):Play()
        TweenService:Create(getStroke, tweenInfo, {Transparency = 0.2}):Play()
    end)

    -- Button hover effects for Check button
    Checkbtn.MouseEnter:Connect(function()
        TweenService:Create(Checkbtn, tweenInfo, {
            BackgroundTransparency = 0,
            Size = UDim2.new(0, 145, 0, 48)
        }):Play()
        TweenService:Create(checkStroke, tweenInfo, {Transparency = 0}):Play()
    end)

    Checkbtn.MouseLeave:Connect(function()
        TweenService:Create(Checkbtn, tweenInfo, {
            BackgroundTransparency = 0.1,
            Size = UDim2.new(0, 140, 0, 45)
        }):Play()
        TweenService:Create(checkStroke, tweenInfo, {Transparency = 0.2}):Play()
    end)

    -- Get Key button functionality
    Getbtn.MouseButton1Click:Connect(function()
        -- Click animation
        TweenService:Create(Getbtn, TweenInfo.new(0.1), {
            BackgroundColor3 = Color3.fromRGB(148, 0, 211),
            Size = UDim2.new(0, 135, 0, 43)
        }):Play()
        
        task.wait(0.1)
        
        TweenService:Create(Getbtn, TweenInfo.new(0.1), {
            BackgroundColor3 = Color3.fromRGB(75, 0, 130),
            Size = UDim2.new(0, 140, 0, 45)
        }):Play()

        local link = "https://workink.net/23KW/olr2h0y6"
        pcall(function()
            setclipboard(link)
        end)
        ShowError("‚úÖ Link copied to clipboard!", Color3.fromRGB(0, 255, 127))
    end)

    -- Check Key button functionality
    Checkbtn.MouseButton1Click:Connect(function()
        -- Click animation
        TweenService:Create(Checkbtn, TweenInfo.new(0.1), {
            BackgroundColor3 = Color3.fromRGB(148, 0, 211),
            Size = UDim2.new(0, 135, 0, 43)
        }):Play()
        
        task.wait(0.1)
        
        TweenService:Create(Checkbtn, TweenInfo.new(0.1), {
            BackgroundColor3 = Color3.fromRGB(75, 0, 130),
            Size = UDim2.new(0, 140, 0, 45)
        }):Play()

        local key = EnterKey.Text
        
        -- Show loading animation
        loadingAnimation.Visible = true
        if stopLoadingAnimation then
            stopLoadingAnimation()
        end
        stopLoadingAnimation = startLoadingAnimation()
        
        -- Simulate processing delay
        wait(1.5)
        
        loadingAnimation.Visible = false
        if stopLoadingAnimation then
            stopLoadingAnimation()
            stopLoadingAnimation = nil
        end
        
        if table.find(ValidKeys, key) then
            ShowError("‚úÖ Valid Key! Welcome to Void Hub!", Color3.fromRGB(0, 255, 127))
            
            -- Save the valid key (this will handle file management)
            VoidHub:SaveKey(key)
            
            -- Success animation
            local successTween = TweenService:Create(Main, tweenInfoBounce, {
                BackgroundColor3 = Color3.fromRGB(0, 100, 0),
                Size = UDim2.new(0, 420, 0, 320)
            })
            successTween:Play()
            
            wait(1)
            
            -- Exit animation
            local exitTween = TweenService:Create(Main, tweenInfo, {
                Size = UDim2.new(0, 0, 0, 0),
                BackgroundTransparency = 1
            })
            exitTween:Play()
            
            local blurTween = TweenService:Create(blur, tweenInfo, {Size = 0})
            blurTween:Play()
            
            exitTween.Completed:Wait()
            Gui:Destroy()
            blur:Destroy()
            
            if ExecuteAfterKey then
                VoidHub:Execute(ExecuteAfterKey)
            end
        else
            ShowError("‚ùå Invalid Key! Please try again.", Color3.fromRGB(255, 69, 58))
            
            -- Shake animation for invalid key
            local shakeTween = TweenService:Create(Main, TweenInfo.new(0.1, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, 6, true), {
                Position = UDim2.new(0.5, 10, 0.5, 0)
            })
            shakeTween:Play()
        end
    end)

    -- Make draggable (PC + Mobile)
    local UIS = game:GetService("UserInputService")
    local dragging, dragInput, dragStart, startPos

    Main.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = Main.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    Main.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UIS.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            local delta = input.Position - dragStart
            Main.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

return VoidHub
